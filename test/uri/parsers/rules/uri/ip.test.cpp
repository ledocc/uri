#define BOOST_TEST_MODULE uri__parsers__rules__uri__ip_hpp
#include <boost/test/unit_test.hpp>


#define BOOST_SPIRIT_QI_DEBUG 1

#include "../../test_parser.hpp"

#include <uri/parsers/rules/uri/ip.hpp>



namespace uri {
namespace parsers {
namespace rules {
namespace uri {
namespace test {

BOOST_AUTO_TEST_CASE( ipV4 )
{
    ip< std::string::const_iterator > ip;

    // clang-format off
    std::vector< std::string > ips = {

        "0.0.0.0",
        "1.1.1.1",
        "2.2.2.2",
        "3.3.3.3",
        "4.4.4.4",
        "5.5.5.5",
        "6.6.6.6",
        "7.7.7.7",
        "8.8.8.8",
        "9.9.9.9",

        "10.10.10.10",
        "20.20.20.20",
        "30.30.30.30",
        "40.40.40.40",
        "50.50.50.50",
        "60.60.60.60",
        "70.70.70.70",
        "80.80.80.80",
        "90.90.90.90",

        "11.19.11.19",
        "22.28.22.28",
        "33.37.33.37",
        "44.46.44.46",
        "55.55.55.55",
        "66.64.66.64",
        "77.73.77.73",
        "88.82.88.82",
        "99.91.99.91",

        "119.111.119.111",
        "128.122.128.122",
        "137.133.137.133",
        "146.144.146.144",
        "155.155.155.155",
        "164.166.164.166",
        "173.177.173.177",
        "182.188.182.188",
        "191.199.191.199",

        "200.200.200.200",
        "255.255.255.255"

    };
    // clang-format on

    std::for_each( ips.begin(), ips.end(), [&ip]( const auto & ipv4 ) {
        parsers::test::test_string_parser( ipv4, ip.v4(), true );
    } );
}


BOOST_AUTO_TEST_CASE( ipV6 )
{
    ip< std::string::const_iterator > ip;
    ip.enable_debug();

    // clang-format off
    std::vector< std::string > ips = {

        "abcd::",

        "abcd::1",
        "abcd::12",
        "abcd::123",
        "abcd::1234",

        "2001:0db8:0100:f101:0210:a4ff:fee3:9566",
        "2001:0DB8:0100:F101:0210:A4FF:FEE3:9566",
        "2001:db8:100:f101:210:a4ff:fee3:9566",
        "2001:0db8:100:f101:0:0:0:1",

        "3:4::5:1.2.3.4",
        "::ffff:1.2.3.4",
        "::0.0.0.0",
        "::255.255.255.255",


        "1:2:3:4:5:6:7:8",

        "::1:2:3:4:5:6:7",
        "::1:2:3:4:5:6",
        "::1:2:3:4:5",
        "::1:2:3:4",
        "::1:2:3",
        "::1:2",
        "::1",
        "::",

        "1::1:2:3:4:5:6",
        "1::1:2:3:4:5",
        "1::1:2:3:4",
        "1::1:2:3",
        "1::1:2",
        "1::1",
        "1::",

        "1:2::1:2:3:4:5",
        "1:2::1:2:3:4",
        "1:2::1:2:3",
        "1:2::1:2",
        "1:2::1",
        "1:2::",

        "1:2:3::1:2:3:4",
        "1:2:3::1:2:3",
        "1:2:3::1:2",
        "1:2:3::1",
        "1:2:3::",

        "1:2:3:4::1:2:3",
        "1:2:3:4::1:2",
        "1:2:3:4::1",
        "1:2:3:4::",

        "1:2:3:4:5::1:2",
        "1:2:3:4:5::1",
        "1:2:3:4:5::",

        "1:2:3:4:5:6::1",
        "1:2:3:4:5:6::",

        "1:2:3:4:5:6:7::",


        "1:2:3:4:5:6:255.255.255.255",

        "::1:2:3:4:5:255.255.255.255",
        "::1:2:3:4:255.255.255.255",
        "::1:2:3:255.255.255.255",
        "::1:2:255.255.255.255",
        "::1:255.255.255.255",
        "::255.255.255.255",

        "1::1:2:3:4:255.255.255.255",
        "1::1:2:3:255.255.255.255",
        "1::1:2:255.255.255.255",
        "1::1:255.255.255.255",
        "1::255.255.255.255",

        "1:2::1:2:3:255.255.255.255",
        "1:2::1:2:255.255.255.255",
        "1:2::1:255.255.255.255",
        "1:2::255.255.255.255",

        "1:2:3::1:2:255.255.255.255",
        "1:2:3::1:255.255.255.255",
        "1:2:3::255.255.255.255",

        "1:2:3:4::1:255.255.255.255",
        "1:2:3:4::255.255.255.255",

        "1:2:3:4:5::255.255.255.255"

    };
    // clang-format on

    std::for_each( ips.begin(), ips.end(), [&ip]( const auto & ipv6 ) {
        parsers::test::test_string_parser( ipv6, ip.v6(), true );
    } );
}

//--------------------------------------------------------------------------------------------------------------------//

BOOST_AUTO_TEST_CASE( ipVFuture )
{
    ip< std::string::const_iterator > ip;
    ip.enable_debug();

    // clang-format off
    std::vector< std::string > ips = {

        "vA.123456",
        "v1.ABCDEF3456",

    };
    // clang-format on

    std::for_each( ips.begin(), ips.end(), [&ip]( const auto & ipvFuture ) {
        parsers::test::test_string_parser( ipvFuture, ip.vFuture(), true );
    } );
}

} // namespace test
} // namespace uri
} // namespace rules
} // namespace parsers
} // namespace uri
